% !TeX root = ../main.tex

\section{Introduzione}
La continua crescita della quantità di dispositivi mobile presenti, e in particolare gli smartphone, ha reso molto importante a livello globale il mercato delle applicazioni e per questo motivo sono sempre di più le aziende che decidono di investire risorse nello sviluppo e nella vendita di applicazioni mobile. Una azienda che intende targettizzare il maggior numero di utenti possibile con le proprie applicazioni deve considerare che l'intero mercato è spartito in base alla diffusione dei sistemi operativi per smartphone. Ad oggi, i sistemi operativi più diffusi sono Android (Google) e iOS (Apple), i quali coprono quasi la totalità del mercato con quote rispettivamente del 71\% e del 28\%\footnote{\href{https://www.statista.com/statistics/272698/global-market-share-held-by-mobile-operating-systems-since-2009/}{https://www.statista.com/statistics/272698/global-market-share-held-by-mobile-operating-systems-since-2009/}}. Questi dati comportano per una azienda la necessità di sviluppare la stessa applicazione per almeno due piattaforme completamente differenti tra loro. A tal proposito sono nate nuove metodologie e tecniche basate sul concetto "Write Once, Run Anywhere" (WORA)\footnote{\href{https://www.computerweekly.com/feature/Write-once-run-anywhere}{https://www.computerweekly.com/feature/Write-once-run-anywhere}} con lo scopo di ottimizzare lo sviluppo delle applicazioni mobile al fine di ridurre i costi e aumentare l'efficienza del processo di sviluppo.

Le principali tecniche moderne di sviluppo per applicazioni mobile sono:
\begin{itemize}
    \item \textbf{Cross-platform} - Rispetta completamente la filosofia WORA. Lo stesso codice può essere eseguito su diverse piattaforme grazie ad uno strato applicativo aggiuntivo che si occupa di interpretare il codice e tradurlo nel linguaggio specifico della piattaforma target.
    \item \textbf{Multi-platform} - Tecnica più recente che permette di sviluppare applicazioni native condividendo solamente la logica applicativa. In questo caso non è necessario uno strato software aggiuntivo perchè la applicazione può essere eseguita direttamente dalla piattaforma target.
\end{itemize}

\section{Cross-platform vs Multi-platform}
Sia nel caso cross-platform che nel caso multi-platform i principali vantaggi, che sono la riduzione dei costi e l'ottimizzazione del processo di sviluppo, derivano dalla condivisione e dal riuso del codice e quindi meno risorse impiegate rispetto allo sviluppo classico delle applicazioni mobile native.

Esistono però alcune differenze tra loro, fondamentali durante la scelta della metodologia da adottare da parte di una azienda per lo sviluppo di una applicazione mobile.
\begin{itemize}
    \item \textbf{Cross-platform}
    \begin{itemize}
        \item Condivisione/riuso totale del codice. Sia la logica applicativa che l'interfaccia utente sono le stesse per qualsiasi piattaforma.
        \item Performance limitate rispetto al nativo, dovute dalla presenza di uno strato software aggiuntivo che interpreta e traduce il codice.
        \item Accesso alle funzionalità hardware del dispositivo limitato e/o con overhead, dovuto sempre dalla presenza dello strato software aggiuntivo.
    \end{itemize}
    \item \textbf{Multi-platform}
    \begin{itemize}
        \item Condivisione/riuso della sola logica applicativa. Lo sviluppo dell'interfaccia utente rimane nativo.
        \item Performance elevate, equivalenti a quelle native.
        \item Accesso completo e senza overhead a tutte le funzionalità hardware del dispositivo.
    \end{itemize}
\end{itemize}

\section{Strumenti}
Tipicamente quando ci si approccia allo sviluppo di una qualsiasi tipologia di software si effettua una ricerca di tutti gli strumenti in grado di facilitare il lavoro dello sviluppatore. Le principali categorie di strumenti necessari sono: (\textit{i}) linguaggio di programmazione, (\textit{ii}) ambiente di sviluppo (IDE\footnote{Integrated Development Environment}), (\textit{iii}) build automation e (\textit{iv}) framework di sviluppo.

La scelta di questi strumenti è spesso vincolata dalla piattaforma target, ovvero l'ambiente dove eseguirà il codice, e lo è in particolare per le applicazioni mobile. A differenza dello sviluppo di applicazioni Android, dove gran parte degli strumenti più diffusi è open-source, lo sviluppo di applicazioni iOS richiede vincoli stringenti imposti da Apple come ad esempio l'utilizzo dell'IDE XCode, il quale è disponibile solamente per il sistema operativo macOS.

Per gli strumenti di build automation esistono diverse alternative per l'ecosistema Android, anche se lo standard de-facto è dato dal tool Gradle. Lo stesso non è vero invece per le applicazioni iOS: come per l'IDE anche in questo caso è necessario utilizzare un insieme di tool specifici indicati da Apple. I più popolari frameworks open-source per lo sviluppo di applicazioni cross-platform sono: (\textit{i}) Ionic, (\textit{ii}) Flutter e (\textit{iii}) React Native. Il paradigma multi-platform è più recente rispetto al quello cross-platform e il principale framework open-source in questo caso è Kotlin Multiplatform.

\subsection{Kotlin Multiplatform Mobile}
Kotlin Multiplatform Mobile\footnote{\href{https://kotlinlang.org/lp/mobile/}{https://kotlinlang.org/lp/mobile/}} (KMM) è un framework per lo sviluppo di applicazioni Android e iOS basato sul concetto di condivisione della logica applicativa mantenendo lo sviluppo nativo della UX/UI.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{img/stack_kmm.png}
    \caption{Stack architetturale Kotlin Multiplatform Mobile.}
    \label{stackKMM}
\end{figure}

Con il rilascio di Kotlin 1.7.20 (Settembre 2022), KMM è passato dalla fase \textit{Alpha} alla fase \textit{Beta} la quale è considerata come fase "\textit{pre-stable}"\footnote{\href{https://kotlinlang.org/docs/components-stability.html\#current-stability-of-kotlin-components}{https://kotlinlang.org/docs/components-stability.html\#current-stability-of-kotlin-components}} ma è comunque già stato adottato in produzione per lo sviluppo delle proprie applicazioni mobile da tante aziende tra le quali è possibile trovare nomi rilevanti come Netflix, VMware e Philips\footnote{\href{https://kotlinlang.org/lp/mobile/case-studies/}{https://kotlinlang.org/lp/mobile/case-studies/}}. In base al risultato dell'indagine di mercato svolta nei primi due quadrimestri del 2021\footnote{\href{https://blog.jetbrains.com/kotlin/2021/10/multiplatform-survey-q1-q2-2021/}{https://blog.jetbrains.com/kotlin/2021/10/multiplatform-survey-q1-q2-2021/}}, le porzioni di codice condiviso nelle applicazioni sviluppate con KMM sono: 85\% networking, 75\% data storage, 70\% utilities, $\sim$60\% algoritmi/computazione, $\sim$55\% state management e $\sim$50\% presenters/controllers/view models.

KMM consiste in un caso d'uso specifico (e il più diffuso) del framework Kotlin MultiPlatform (KMP), il quale permette di sviluppare il codice in modo agnostico rispetto le piattaforme target e di condividerlo tra differenti piattaforme. Il framework KMM è fortemente basato sui seguenti compilatori inclusi nell'ecosistema Kotlin~\cite{nagy2022simplifying}:

\begin{itemize}
    \item \textbf{Kotlin/JVM} - Utilizzato per la piattaforma Android, permette di compilare codice Kotlin in bytecode Java (\textit{.class}), il quale può essere eseguito direttamente sulla JVM. Nel caso di Android è necessario un ulteriore passaggio per tradurre il bytecode Java in bytecode Dalvik (\textit{.dex}).

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\textwidth]{img/compilatore_kotlin.png}
        \caption{Fasi di compilazione Kotlin/JVM e Kotlin/Native.}
    \end{figure}

    \item \textbf{Kotlin/Native} - Utilizzato per la piattaforma iOS. A differenza del compilatore Kotlin/JVM, il compilatore Kotlin/Native è progettato per quelle situazioni dove non è possibile o non si vuole avere una VM come nel caso dei dispositivi embedded e della piattaforma iOS. Per fare ciò include un backend basato su \textit{Low Level Virtual Machine} (LLVM)\footnote{\href{https://llvm.org/}{https://llvm.org/}} in grado di compilare il codice Kotlin in binari nativi che possono essere eseguiti senza VM\cite{nagy2022simplifying}. Le piattaforme supportate da Kotlin/Native attualmente sono macOS, iOS, tvOS, watchOS, Linux, Windows (MinGW) e Android NDK\footnote{\href{https://kotlinlang.org/docs/native-overview.html\#target-platforms}{https://kotlinlang.org/docs/native-overview.html\#target-platforms}} e per ognuna di esse esistono differenti architetture. Nel caso di iOS le differenti architetture supportate da KMM sono \textit{Arm64}, \textit{Arm32} e \textit{x64}. Anche in questo caso sono necessarie due fasi di compilazione: (\textit{i}) il codice Kotlin viene compilato nella \textit{Rappresentazione Intermedia} (IR) LLVM e (\textit{ii}) successivamente compilato nel binario nativo.
\end{itemize}

\subsubsection{Expect/Actual}
Quando si sviluppa codice condiviso è spesso necessario definire come determinate funzionalità debbano essere implementate sulla specifica piattaforma target per utilizzare i relativi SDK. Il framework KMM fornisce il meccanismo \textit{expect/actual} per assolvere a questo compito in modo del tutto analogo al design pattern \textit{Template Method}:
\begin{itemize}
    \item \textbf{Expect} - Astrazione della funzionalità necessaria. Tramite la keywork \textit{expect} si definisce lo scheletro astraendo dalla specifica implementazione.
    \item \textbf{Actual} - Implementazione specifica per una determinata piattaforma. Tramite la keywork \textit{actual} si definisce l'implementazione, reificando l'astrazione definita tramite il concetto di \textit{expect}.
\end{itemize}

% inserire codice nel repo github
\begin{listing}[H]
\inputminted{kotlin}{code/3-expectactual}
\caption{Esempio di applicazione expect/actual per ottenere informazioni sulla piattaforma.}
\end{listing}

\subsubsection{Struttura Applicazione KMM}
Una applicazione sviluppata con KMM segue lo stack definito dalla condivisione della business logic e la separazione della UX/UI (figura \ref{stackKMM}). Il modulo \textit{shared} contiene tutta la business logic condivisa, la quale può essere sviluppata tramite l'utilizzo di librerie con supporto nativo al framework KMM, cioè librerie che forniscono già al loro interno specifiche implementazioni per le diverse piattaforme target, oppure tramite l'utilizzo del meccanismo expect/actual.

Nel caso di utilizzo del meccanismo expect/actual è necessario definire le funzionalità nel modulo \textit{commonMain} e fornire le implementazioni per le specifiche piattaforme nei relativi moduli \textit{androidMain} e \textit{iosMain}. Gli stessi concetti vengono applicati per la struttura dei moduli di test: \textit{commonTest}, \textit{androidTest} e \textit{iosTest}.

I moduli UX/UI delle relative piattaforme includono il codice condiviso come dipendenza di progetto, in particolare come dipendenza Gradle (\textit{aar}\footnote{Android Archive}) per Android e come dipendenza CocoaPods (Pod) per iOS.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{img/struttura_app_kmm.png}
    \caption{Struttura dei moduli di una applicazione KMM.}
\end{figure}

\subsubsection{KMM Gradle Plugins}
Gli strumenti di build automation permettono la gestione di tutti quei task riguardanti la compilazione del codice. Gradle rappresenta il tool di build automation ufficiale Android ed è possibile sviluppare delle estensioni, chiamate plugins, per aggiungere task custom allo strumento. E' proprio tramite questo meccanismo che KMM permette l'esecuzione dei task relativi allo sviluppo di applicazioni mobile multiplatform.

Il plugin Gradle KMM fornisce uno specifico DSL\footnote{Domain Specific Language} per definire e configurare i task necessari a compilare il codice condiviso per le relative piattaforme target\footnote{\href{https://kotlinlang.org/docs/multiplatform-dsl-reference.html}{https://kotlinlang.org/docs/multiplatform-dsl-reference.html}}. Alcune delle principali tipologie di task sono:

\begin{itemize}
    \item \textbf{Build} - tasks per build, compile, link
    \item \textbf{CocoaPods} - tasks per la gestione delle dipendenze Swift/Objective-C
    \item \textbf{Interop} - tasks relativi all'utilizzo del \textit{commonizer}\footnote{\href{https://github.com/JetBrains/kotlin/tree/master/native/commonizer}{https://github.com/JetBrains/kotlin/tree/master/native/commonizer}}
    \item \textbf{Verification tasks} - tasks per l'esecuzione dei test
\end{itemize}

Lo strumento di build automation Gradle e i relativi plugins utilizzati vengono configurati tramite specifici file locati tra i sorgenti del progetto:

% aggiungere codice al repo github
\begin{listing}[H]
\inputminted{kotlin}{code/3-gradlekmm1}
\caption{Struttura iniziale del file \textit{settings.gradle.kts} nella root di progetto (Kotlin).}
\end{listing}

\begin{listing}[H]
\inputminted{kotlin}{code/3-gradlekmm2}
\caption{Definizione utilizzo Plugin Gradle KMM nel file \textit{build.gradle.kts} del modulo condiviso (Kotlin).}
\end{listing}

\subsection{Fastlane}
% descrizione di fastlane, il quale viene utilizzato in cicd nel capitolo successivo

%Data la necessità di sviluppare applicazioni per le due differenti piattaforme Android e iOS è anche necessario utilizzare differenti strumenti di build automation per l'esecuzione dei task del processo di sviluppo.

%Come abbiamo visto in questo capitolo il processo di sviluppo delle applicazioni mobile comprende anche altre fasi oltre a quelle di progettazione e scrittura del codice. Lo sviluppatore deve essere infatti in grado di poter 