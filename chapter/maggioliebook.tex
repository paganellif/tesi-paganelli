% !TeX root = ../main.tex

% inserire da qualche parte (capire se mglio all'inizio per tutti i moduli oppure in ogni implementazione dei moduli)
% le configurazioni dei tool necessarie per lo sviluppo kmm e la ci: come gradle, plugin, detekt, sonar, sqldelight ecc

\section{Introduzione}
Dato il processo di sviluppo e configurato il sistema di automazione è possibile partire con lo sviluppo effettivo della applicazione mobile multipiattaforma MaggioliEbook. In questo capitolo vengono descritte le fasi di progettazione e implementazione di una applicazione mobile tramite l'utilizzo del framework Kotlin Multiplatform Mobile, rispettando i requisiti definiti nel capitolo \ref{ch:casodistudio}.

\section{Progettazione}
La fase di progettazione, come anticipato nel capitolo \ref{ch:sdlc}, comprende diverse attività tra cui le principali sono (\textit{i}) la modellazione del dominio, (\textit{ii})la progettazione dell'interfaccia grafica/esperienza utente tramite l'ausilio di mockup e (\textit{iii}) la progettazione della architettura.

\subsection{Modellazione del dominio}
Seguendo la cultura Domain-Driven Design adottata per la raccolta dei requisiti e per la definizione dei casi d'uso e della terminologia è necessario individuare i differenti contesti al fine di realizzare una mappa, detta \textit{Context Map}, utile a dare una visione globale del progetto e delle relazioni tra i vari contesti~\cite{evans_domain-driven_2004}.

La context map è composta dai seguenti tre contesti:

\begin{itemize}
    \item \textbf{Reader} (Core) - Contesto principale del progetto. Racchiude tutti gli aspetti con maggiore valore per l'utente riguardanti la lettura e la personalizzazione dei contenuti digitali. 
    \item \textbf{Sisred} - Rappresenta il contesto della sorgente dei contenuti digitali Maggioli. In questo contesto non esistono i concetti di \textit{favorite}, \textit{highlight}, \textit{bookmark} e \textit{progression} mentre è condiviso il concetto di libro e utente.
    \item \textbf{User} - Contesto che definisce tutti gli aspetti a riguardo degli utenti. In questo contesto esiste il solo concetto di utente, il quale è condiviso con gli altri contesti.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img/ddd-context-map.png}
    \caption{Panoramica globale dei contesti del progetto e delle relazioni che intercorrono tra di essi}
    \label{context-map-png}
\end{figure}

Tra i contesti definiti esistono delle relazioni di tipo \textit{Shared Kernel}~\cite{evans_domain-driven_2004} (SK) con l'obiettivo di evitare duplicazioni e semplificare l'integrazione. Relazioni di questo tipo consistono nella condivisione di un sottoinsieme del dominio modellato, che corrisponde tipicamente al dominio core. Un esempio di relazione SK è l'utilizzo di codice o schemi DB condivisi\footnote{\href{https://github.com/ddd-crew/context-mapping}{https://github.com/ddd-crew/context-mapping}}.

Per la modellazione del dominio si fa uso dei seguenti concetti\cite{evans_domain-driven_2004}:
\begin{itemize}
    \item \textbf{Entity} - Oggetto definito dalla sua identità e non dai suoi attributi. Ogni libro è univoco, identificato da uno specifico codice, chiamato ISBN\footnote{International Standard Book Number}.
    \item \textbf{Value Object} - Al contrario delle entità, questi oggetti sono definiti dai loro attributi e non hanno una identità concettuale ma servono a descrivere alcune caratteristiche di un oggetto. Un esempio è il segnalibro: ciò che è rilevante è la pagina del libro che esso referenzia e non la sua identità.

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{img/class-uml-app.png}
        \caption{UML - Diagramma delle classi: Reader Core Domain e User Subdomain}
        \label{class-uml-app}
    \end{figure}
    
    \item \textbf{Aggregate} - Insieme di oggetti legati da una entità padre chiamata \textit{Root} (radice di aggregazione). L'aggregato composto da \textit{Bookmark}, \textit{Highlight}, \textit{Progression}, \textit{Favorite} ha come radice l'entità \textit{Libro}.
    \item \textbf{Service} - Operazione che non appartiene logicamente a nessun oggetto. In questo caso la conversione di formato non appartiene alla sola entità libro ma appartiene invece a qualsiasi documento che è possibile convertire.
    \item \textbf{Repository} - Oggetto per il recupero di altri oggetti di dominio e per la gestione del loro ciclo di vita. Le entità \textit{User} e \textit{Libro} sono esempi di oggetti di dominio che necessitano di un repository. Permette di disaccoppiare applicazione e domain design dalle specifiche tecnologie/strategie di persistenza come multipli database e datasource (locali e/o remoti).
\end{itemize}

\subsection{Progettazione UI/UX}
Successivamente alla modellazione del dominio e alla progettazione della architettura, le quali coinvolgono principalmente il modulo condiviso alle due applicazioni che si intende sviluppare grazie al framework KMM, è necessario progettare l'interfaccia grafica e l'esperienza utente che dovrà essere implementata invece per le rispettive piattaforme Android e iOS. Considerando l'utilizzo tipico di una applicazione con funzionalità simili a quella deve essere realizzata possono essere adottati pattern di navigazione e visualizzazione dei contenuti diventati oramai standard de-facto nella progettazione della UI/UX non solo per applicazioni mobile\footnote{\href{https://xd.adobe.com/ideas/principles/app-design/}{https://xd.adobe.com/ideas/principles/app-design/}}.

Alcuni esempi di questi elementi utilizzati sono il menu laterale a scomparsa (schermata 4), l'icona "hamburger" per l'apertura del menu (schermata 3),l' elenco di documenti con scroll infinito verticale (schermata 2-5) e la barra di ricerca nella parte alta della schermata con icona "lente di ingrandimento" (schermata 2-5). 

Per ottenere la validazione dei mockup da parte del committente sono state necessarie due iterazioni del processo di progettazione UX/UI. L'interfaccia utente desiderata deve infatti soddisfare alcuni vincoli caratteristici del brand Maggioli, come ad esempio l' utilizzo del colore blu \#00379E come colore primario, l'utilizzo del font Karla\footnote{\href{https://github.com/googlefonts/karla}{https://github.com/googlefonts/karla}} e la presenza del logo Maggioli.

Le schermate necessarie sono quindi: \textit{Reader}, responsabile della visualizzazione del contenuto digitale in formato EPUB; \textit{Login}, schermata iniziale responsabile alla autenticazione dell'utente; \textit{Home}, schermata principale responsabile alla visualizzazione dei contenuti digitali a cui l'utente è autorizzato ad accedere; \textit{Preferiti}, responsabile alla visualizzazione dei contenuti digitali preferiti dall'utente; \textit{Impostazioni}, responsabile alla visualizzazione e modifica delle impostazioni; \textit{About}, responsabile alla visualizzazione di informazioni generali come versione della applicazione, autore e copyright.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img/mockup-uiux-1.png}
    \caption{Alcuni dei mockup realizzati per la progettazione e la validazione della UX/UI (prima iterazione)}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img/mockup-uiux-2.png}
    \caption{Modifiche apportate ai mockup per ottenere la validazione della UX/UI (seconda iterazione)}
\end{figure}

\subsection{Architettura}
Lo scopo di una applicazione multipiattaforma è la condivisione della sola logica applicativa come mostrato nella struttura di un applicazione KMM (fig. \ref{stackKMM}). L'architettura in grado di supportare efficacemente questo concetto è conosciuta come \textit{Clean Architecture}~\cite{martin2017architecture} ed è composta da tre strati. Il primo strato (\textit{Data Layer}) consiste negli aggregati di dominio sopra descritti ed è responsabile per il recupero e il mantenimento dei dati su differenti sorgenti. Il secondo strato (\textit{Domain Layer}) facilità la comunicazione tra i differenti repository: qui si trovano tutti i casi d'uso del sistema che gestiscono il flusso dei dati provenienti o diretti verso il primo strato. Il terzo ed ultimo strato (\textit{View Layer}) si occupa della interfaccia grafica mostrando i dati e gestendo gli eventi provenienti dall'utente o dal sistema.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{img/clean-architecture.png}
    \caption{Clean Architecture in MaggioliEbook}
    \label{clean-arch-kmm-fig}
\end{figure}

\section{Sviluppo}
Tipicamente lo sviluppo effettivo di una applicazione multiplatform con il framework KMM ha inizio con la creazione dello scheletro della applicazione tramite l'IDE Android Studio e il relativo plugin Gradle KMM, come indicato nel capitolo \ref{ch:app-multiplatform}.

La prima attività successiva alla creazione dello scheletro del progetto consiste nella ricerca delle librerie, ovvero le stesse dipendenze che sono gestite in modo automatico dal sistema come descritto nel capitolo precedente. Considerando le funzionalità che devono essere implementate è necessario individuare tutte le librerie utili partendo da quelle core, come la visualizzazione e la modifica dei documenti, a quelle di utilità a supporto del modulo condiviso come networking e storage. Raggruppate per modulo di utilizzo, le librerie individuate e adottate sono:

\subsubsection*{Shared}
\begin{itemize} 
    \item \textbf{Ktor}\footnote{\href{https://github.com/ktorio/ktor}{https://github.com/ktorio/ktor}} - Framework asincrono per lo sviluppo di microservizi e applicazioni web, utilizzato per la parte di networking come client HTTP.
    \item \textbf{Kotlinx-Serialization} - Libreria multiplatform per la serializzazione dei dati.
    \item \textbf{Kotlinx-Datetime} - Libreria multiplatform per la gestione delle date e del tempo.
    \item \textbf{Kvault}\footnote{\href{https://github.com/Liftric/KVault}{https://github.com/Liftric/KVault}} - Libreria multiplatform per la persistenza dei dati sicura in formato chiave-valore. Tramite una unica API si comporta come wrapper di \textit{Keychain}, nel caso iOS, e \textit{SharedPreferences} nel caso Android.
    \item \textbf{Koin}\footnote{\href{https://github.com/InsertKoinIO/koin}{https://github.com/InsertKoinIO/koin}} - Dependency Injection framework multiplatform.
    \item \textbf{Napier}\footnote{\href{https://github.com/AAkira/Napier}{https://github.com/AAkira/Napier}} - Logging framework multiplatform.
    \item \textbf{SqlDelight}\footnote{\href{https://github.com/cashapp/sqldelight}{https://github.com/cashapp/sqldelight}} - Libreria multiplatform per la persistenza dei dati tramite database relazionale locale.
\end{itemize}

\subsubsection*{Android}
\begin{itemize}
    \item \textbf{Readium} (\textit{Kotlin-toolkit})\footnote{\href{https://github.com/readium/kotlin-toolkit}{https://github.com/readium/kotlin-toolkit}} - Libreria per la manipolazione e la visualizzazione di pubblicazioni digitali. Implementazione specifica per la piattaforma Android. 
\end{itemize}

\subsubsection*{iOS}
\begin{itemize}
    \item \textbf{Readium} (\textit{Swift-toolkit})\footnote{\href{https://github.com/readium/swift-toolkit}{https://github.com/readium/swift-toolkit}} - Libreria per la manipolazione e la visualizzazione di pubblicazioni digitali. Implementazione specifica per la piattaforma iOS. 
    \item \textbf{KMPNativeCoroutines}\footnote{\href{https://github.com/rickclephas/KMP-NativeCoroutines}{https://github.com/rickclephas/KMP-NativeCoroutines}} - Libreria che permette l'utilizzo delle coroutine Kotlin in Swift in applicazioni Kotlin Multiplatform.
\end{itemize}
    
\subsection{Readium}
La necessità di un tool open-source, robusto e performante per la manipolazione e la lettura di formati editoriali digitali è alla base del progetto Readium. Essa infatti consiste in un insieme di toolkit per diversi formati (come EPUB, audiolibri e libri image-based) e diverse piattaforme (Android, iOS, Desktop e Web).

L'architettura della libreria Readium è composta da quattro moduli principali:
\begin{itemize}
    \item \textbf{Publication Server} - Fornisce le pubblicazioni tramite un server locale HTTPS.
    \item \textbf{Streamer} - Modulo composto dai seguenti due sottomoduli:
    \begin{itemize}
        \item \textbf{Parser} - Responsabile del parsing delle pubblicazioni e della loro esposizione utilizzando un modello in-memory.
        \item \textbf{Fetcher} - Si occupa di ottenere i contenuti delle pubblicazioni e della loro manipolazione (in particolare injection di CSS e Javascript nelle risorse HTML).
    \end{itemize}
    \item \textbf{Navigator} - Utile alla navigazione delle risorse di una pubblicazione secondo diverse strategie basate sulla natura della pubblicazione (ebook, audiolibri, ...). Interagisce con il modulo \textit{Streamer} per utilizzare il modello in-memory o per ottenere il manifesto JSON attraverso il modello condiviso (\textit{Shared}).
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{img/readium-arch.png}
    \caption{Architettura libreria Readium}
    \label{readiumarch}
\end{figure}

\subsection{Modulo Shared}
Come anticipato nel capitolo \ref{ch:app-multiplatform} la parte condivisa di una applicazione multipiattaforma racchiude tutta o una sottoparte della logica applicativa, compresi quindi anche aspetti "infrastrutturali" specifici della piattaforma target come ad esempio logging, persistenza dei dati e networking.

Gli elementi del dominio che sono stati aggiunti dal contesto core (fig. context-map-png) devono essere persistiti sul dispositivo locale ed è necessario svolgere operazioni CRUD\footnote{Create-Read-Update-Delete} come su qualsiasi database, che sia locale o remoto. I relativi schemi per il database locale sono stati definiti utilizzando appositi file\footnote{\href{https://github.com/paganellif/DevOps-per-applicazioni-mobile-un-caso-di-studio-industriale/tree/6-sviluppo-applicazione-maggioliebook/maggioliEbookApp/shared/src/commonMain/sqldelight/it/filo/maggioliebook/db}{https://github.com/paganellif/DevOps-per-applicazioni-mobile-un-caso-di-studio-industriale/tree/6-sviluppo-applicazione-maggioliebook/maggioliEbookApp/shared/src/\\commonMain/sqldelight/it/filo/maggioliebook/db}}, uno per ognuna delle entità che necessita di persistenza: \textit{Highlight}, \textit{Favorite}, \textit{Progression} e \textit{Bookmark}.

Il seguente codice\footnote{\href{https://github.com/paganellif/DevOps-per-applicazioni-mobile-un-caso-di-studio-industriale/blob/6-sviluppo-applicazione-maggioliebook/maggioliEbookApp/shared/src/commonMain/sqldelight/it/filo/maggioliebook/db/Bookmark.sq}{https://github.com/paganellif/DevOps-per-applicazioni-mobile-un-caso-di-studio-industriale/blob/6-sviluppo-applicazione-maggioliebook/maggioliEbookApp/shared/src/\\commonMain/sqldelight/it/filo/maggioliebook/db/Bookmark.sq}} definisce tramite la sintassi SqlDelight lo schema \textit{Bookmark} e l'operazione associata di selezione tramite ISBN:

\begin{listing}[H]
    \inputminted{sql}{code/bookmark-sqldelight.sq}
    \caption{Esempio di definizione schema \textit{Bookmark} tramite sintassi SqlDelight}
\end{listing}

Tramite il task \textit{generateSqlDelightInterface} fornito dal plugin gradle SqlDelight è possibile generare automaticamente l'interfaccia padre \textit{MaggioliEbookDB} e le relative implementazioni. Nel caso dello schema sopra indicato si ottiene il seguente codice\footnote{\href{https://github.com/paganellif/DevOps-per-applicazioni-mobile-un-caso-di-studio-industriale/blob/6-sviluppo-applicazione-maggioliebook/maggioliEbookApp/shared/build/generated/sqldelight/code/MaggioliEbookDB/commonMain/it/filo/maggioliebook/db/BookmarkQueries.kt}{https://github.com/paganellif/DevOps-per-applicazioni-mobile-un-caso-di-studio-industriale/blob/6-sviluppo-applicazione-maggioliebook/maggioliEbookApp/shared/build/generated/\\sqldelight/code/MaggioliEbookDB/commonMain/it/filo/maggioliebook/db/BookmarkQueries.kt}} Kotlin:

\begin{listing}[H]
    \inputminted{kotlin}{code/bookmark-sqldelight.kt}
    \caption{Codice Kotlin autogenerato per lo schema \textit{Bookmark} tramite SqlDelight}
\end{listing}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img/uml-network-db.png}
    \caption{UML - Diagramma delle classi: Implementazioni data source (persistenza dati e networking)}
\end{figure}

Tipicamente le librerie per applicazioni sviluppate con Kotlin Multiplatform possono essere utilizzate direttamente dal codice condiviso, come ad esempio KVault, lasciando al compilatore Kotlin il compito di scegliere la giusta implementazione per la piattaforma target durante la fase di compilazione. In altri casi è necessario invece utilizzare il meccanismo \textit{expect/actual} (discusso nel capitolo \ref{ch:app-multiplatform}) per definire il comportamento atteso e fornire una implementazione specifica per la piattaforma target.

Tale meccanismo è stato utilizzato nello sviluppo della applicazione per poter effettuare dependency injection tramite la libreria Koin dei componenti riguardanti la persistenza dei dati (Kvault e SqlDelight) e l'esecuzione asincrona (CoroutineDispatcher).

Ogni dipendenza che deve essere iniettata viene inserita all'interno di uno o più moduli, i quali vengono utilizzati da Koin per inizializzare tutto il contesto applicativo. Le dipendenze possono essere principalmente di due tipi:
\begin{itemize}
    \item \textbf{Factory} - Ogni volta che la dipendenza viene iniettata ne viene creata una nuova istanza (paragonabile al design pattern Factory Method~\cite{gamma1994design}).
    \item \textbf{Single} - In tutto il contesto applicativo esiste una sola istanza della dipendenza iniettata (paragonabile al design pattern Singleton~\cite{gamma1994design}).
\end{itemize}

\begin{listing}[H]
    \inputminted{kotlin}{code/shared-di-koin.kt}
    \caption{Configurazione Dependency Injection: definizione dei moduli Koin e inizializzazione del contesto applicativo}
\end{listing}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img/expect-actual-shared.png}
    \caption{Strategia \textit{Expect/Actual} adottata per l'implementazione dei servizi infrastrutturali specifici delle piattaforme, persistenza e concorrenza, sfruttando la tecnica \textit{dependency injection}}
\end{figure}

\subsection{Applicazione Android}
Completato lo sviluppo della logica applicativa condivisa e quindi gli strati \textit{Domain} e \textit{Data} (fig. \ref{clean-arch-kmm-fig}) della architettura, è possibile iniziare lo sviluppo dello strato \textit{View}. In questa fase si realizza la vera e propria applicazione Android, sfruttando il toolkit Kotlin della libreria Readium per la funzionalità core di lettura dei contenuti digitali.

\subsubsection*{Single-Activity Architecture}
L'architettura scelta per l'implementazione della applicazione Android\footnote{\href{https://github.com/paganellif/DevOps-per-applicazioni-mobile-un-caso-di-studio-industriale/tree/6-sviluppo-applicazione-maggioliebook/maggioliEbookApp/androidMaggioliEbookApp/src/main/java/it/filo/maggioliebook/android}{https://github.com/paganellif/DevOps-per-applicazioni-mobile-un-caso-di-studio-industriale/tree/6-sviluppo-applicazione-maggioliebook/maggioliEbookApp/androidMaggioliEbookApp/\\src/main/java/it/filo/maggioliebook/android}} è basata su sole due activity:

\begin{itemize}
    \item \textbf{MainActivity} - Unica activity principale della applicazione.
    \item \textbf{ReaderActivity} - Activity secondaria, utilizzata sia per l'interazione che la gestione del lettore delle pubblicazioni digitali.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{img/android-arch.png}
    \caption{Architettura Single-Activity adottata per l'applicazione Android}
    \label{android-arch-png}
\end{figure}

Questa tipologia di architettura permette di avere una singola activity che svolge la funzione di contenitore per tutti i fragment che rappresentano le varie schermate, definite in fase di progettazione della UI/UX, in cui l'utente può navigare.

La navigazione all'interno della applicazione è gestita tramite la combinazione dei seguenti componenti:
\begin{itemize}
    \item \textbf{NavController} - Componente necessario per la gestione delle transizioni da un un fragment all'altro. Quando inizializzato richiede la presenza di un grafo di navigazione tra le risorse XML: tale grafo contiene tutti i fragment che possono essere visualizzati e le possibili transizioni tra di essi.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.95\textwidth]{img/android-nav-graph.png}
        \caption{Sottoparte del navigation graph della applicazione, renderizzato automaticamente tramite l'IDE Android Studio}
        \label{android-nav-graph-png}
    \end{figure}
    
    \item \textbf{NavHostFragment} - Rappresenta il contenitore del fragment in cui ci si trova. Ogni transizione nel grafo corrisponde alla sostituzione del fragment visualizzato con quello di destinazione (sempre che la transizione sia ammessa dal grafo).
    \item \textbf{NavigationView} - Permette la visualizzazione del menu dove si trovano i possibili fragment raggiungibili da quello in cui l'utente si trova attualmente. Nel caso della applicazione sviluppata in questo componente si trova il menu laterale con tutte le schermate indicate in fase di progettazione (\textit{Home}, \textit{Settings}, \textit{About} e \textit{Preferiti}).
\end{itemize}

Come indicato nella figura \ref{android-nav-graph-png} la schermata principale (\textit{Home}) rappresenta la destinazione iniziale del grafo, ovvero la prima schermata che viene visualizzata dalla applicazione. L'autenticazione dell'utente è gestita tramite la navigazione condizionale\footnote{\href{https://developer.android.com/guide/navigation/navigation-conditional}{https://developer.android.com/guide/navigation/navigation-conditional}}. 

Prima di creare la vista del fragment viene effettuato un controllo sulla autenticazione dell'utente: se l'utente non è autenticato viene effettuata una transizione al fragment \textit{Login} per permettere all'utente di autenticarsi e procedere all'utilizzo della applicazione. E' fondamentale in questo scenario ripulire lo stack di navigazione per evitare che l'utente possa tornare indietro alla schermata precedente, ovvero la schermata principale, senza effettuare l'autenticazione.

\subsubsection*{Paging}
\label{pagingsec}
Un altro aspetto importante della architettura è il meccanismo utilizzato sia dalla schermata principale che da quella dei preferiti per mostrare i dati all'utente. Il backend utilizzato fornisce i dati tramite paginazione: in questo modo è possibile indicare in una richiesta la dimensione delle pagine, ovvero quanti elementi devono essere restituiti al massimo in una pagina, e la pagina desiderata. 

Per poter caricare tali dati dinamicamente in una \textit{RecyclerView}\footnote{\href{https://developer.android.com/reference/kotlin/androidx/recyclerview/widget/RecyclerView}{https://developer.android.com/reference/kotlin/androidx/recyclerview/widget/RecyclerView}} in modo da permettere all'utente di effettuare lo scroll "infinito" è stata utilizzata\footnote{\href{https://github.com/paganellif/DevOps-per-applicazioni-mobile-un-caso-di-studio-industriale/blob/6-sviluppo-applicazione-maggioliebook/maggioliEbookApp/androidMaggioliEbookApp/src/main/java/it/filo/maggioliebook/android/home/LibroPagingSource.kt}{https://github.com/paganellif/DevOps-per-applicazioni-mobile-un-caso-di-studio-industriale/blob/6-sviluppo-applicazione-maggioliebook/maggioliEbookApp/androidMaggioliEbookApp/\\src/main/java/it/filo/maggioliebook/android/home/LibroPagingSource.kt}} la libreria \textit{Paging}\footnote{\href{https://developer.android.com/topic/libraries/architecture/paging/v3-overview}{https://developer.android.com/topic/libraries/architecture/paging/v3-overview}} fornita nativamente dall'SDK Android.

\begin{comment}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{img/android-paging.png}
    \caption{Flusso generico dei dati dalla sorgente alla UI tramite l'utilizzo della libreria Paging}
    \label{android-paging}
\end{figure}
\end{comment}

I componenti fondamentali della libreria \textit{Paging} sono:
\begin{itemize}
    \item \textbf{Pager} - Punto di ingresso principale della libreria con il compito di ottenere nuovi dati quando necessario, ovvero quando l'utente ha scrollato nella schermata fino ad uno specifico punto. Richiede la configurazione di alcuni parametri come la dimensione della pagina, la pagina iniziale e la direzione della paginazione. 
    \item \textbf{PagingSource} - Sorgente dei dati paginati. Componente interrogato dal \textit{Pager} ogni volta che sono necessari nuovi dati.
    \item \textbf{PagingDataAdapter} - Componente fondamentale per la rappresentazione di dati paginati in una \textit{RecyclerView}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{img/android-viewmodel.png}
    \caption{UML - Diagramma delle classi: Paginazione dati nella schermata principale}
    \label{android-viewmodel-png}
\end{figure}

\subsubsection*{Reader}
Il lettore dei documenti digitali in formato EPUB rappresenta la funzionalità core della applicazione sviluppata. Nel caso della interfaccia grafica android il lettore riceve il contenuto da visualizzare del documento selezionato dall'utente e lo mostra in un fragment basato sul componente \textit{Navigator} (fig. \ref{readiumarch}). Questo componente della libreria Readium fornisce tutte le funzionalità necessarie per gestire la navigazione dei documenti e gli eventi relativi al comportamento dell'utente come scorrimento pagine e selezione testo. I principali componenti sviluppati\footnote{\href{https://github.com/paganellif/DevOps-per-applicazioni-mobile-un-caso-di-studio-industriale/tree/6-sviluppo-applicazione-maggioliebook/maggioliEbookApp/androidMaggioliEbookApp/src/main/java/it/filo/maggioliebook/android/reader}{https://github.com/paganellif/DevOps-per-applicazioni-mobile-un-caso-di-studio-industriale/tree/6-sviluppo-applicazione-maggioliebook/maggioliEbookApp/androidMaggioliEbookApp/\\src/main/java/it/filo/maggioliebook/android/reader}} per le funzionalità del reader sono:

\begin{itemize}
    \item \textbf{ReaderActivity} - Unica activity presente nella applicazione oltre a quella principale (Single Activity Architecture), utilizzata sia per l’interazione che la gestione del lettore di contenuti digitali.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.82\textwidth]{img/reader-uml.png}
        \caption{UML - Diagramma delle classi: Reader}
        \label{reader-uml}
    \end{figure}
    
    \item \textbf{EpubReaderFragment} - Componente che si occupa effettivamente di mostrare il contenuto del documento all'utente.
    \item \textbf{DecorationListener} - Permette la gestione grafica delle annotazioni come evidenziazioni e sottolineature, le quali sono aggiunte alla vista del fragment tramite l'utilizzo di Jetpack Compose.
\end{itemize}

\subsubsection*{Screenshot}
\begin{multicols}{3}
            \begin{figure}[H]
                \centering
                \includegraphics[width=0.21\textwidth]{img/login.png}
                \caption{Login}
                \label{login-android}
            \end{figure}

            \begin{figure}[H]
                \centering
                \includegraphics[width=0.21\textwidth]{img/sidenav.png}
                \caption{Menu laterale - Sidenav}
                \label{sidenav-android}
            \end{figure}
            
            \begin{figure}[H]
                \centering
                \includegraphics[width=0.21\textwidth]{img/home.png}
                \caption{Schermata home principale}
                \label{home-android}
            \end{figure}
            
            \begin{figure}[H]
                \centering
                \includegraphics[width=0.21\textwidth]{img/ricerca.png}
                \caption{Esempio di ricerca}
                \label{ricerca-android}
            \end{figure}

            \begin{figure}[H]
                \centering
                \includegraphics[width=0.21\textwidth]{img/preferiti.png}
                \caption{Preferiti}
                \label{preferiti-android}
            \end{figure}

            \begin{figure}[H]
                \centering
                \includegraphics[width=0.21\textwidth]{img/about.png}
                \caption{Info generali (About)}
                \label{about-android}
            \end{figure}

            \begin{figure}[H]
                \centering
                \includegraphics[width=0.21\textwidth]{img/reader_settings.png}
                \caption{Reader}
                \label{readersettings-android}
            \end{figure}
            
            \begin{figure}[H]
                \centering
                \includegraphics[width=0.21\textwidth]{img/annotations.png}
                \caption{Esempio di annotazioni, evidenziazioni, sottolineature, ...}
                \label{annotations-android}
            \end{figure}
            
            \begin{figure}[H]
                \centering
                \includegraphics[width=0.21\textwidth]{img/annotation2.png}
                \caption{Annotazioni memorizzate}
                \label{annotation2-android}
            \end{figure}

            \begin{figure}[H]
                \centering
                \includegraphics[width=0.21\textwidth]{img/toc.png}
                \caption{Elenco dei contenuti (TOC) del documento}
                \label{toc-android}
            \end{figure}
            
            \begin{figure}[H]
                \centering
                \includegraphics[width=0.21\textwidth]{img/ricerca_testo.png}
                \caption{Ricerca testuale nel contenuto del documento}
                \label{ricerca_testo-android}
            \end{figure}
            
            \begin{figure}[H]
                \centering
                \includegraphics[width=0.21\textwidth]{img/ricerca_testo2.png}
                \caption{Evidenziazioni automatiche delle occorrenze del testo cercato}
                \label{ricerca_testo2-android}
            \end{figure}
\end{multicols}

\subsection{Applicazione iOS}
% implementazione app iOS
